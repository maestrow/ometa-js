# Краткосрочный план

- метод-утилита: убрать lr 
- тесты: Старая и новая ометы парсят старую и новую омету
- IProjections заменить на ICustomParsers
- Переименовать state в context. А state - это будет users state. Он будет внутри контекста. InitState


# План

Step4
- поддержка левой рекурсии
- переписать грамматику Ometa с использованием левой рекурсии
- Новый функционал Ometa реализуется на Ometa - bootstrapping

Step5
- Поддержка состояния без отката назад

Step6
- Привязка выражений к переменным
- Вызов правил с аргументами

Step7
- Сопоставление по шаблону на массивы
- Сопоставление по шаблону при выдове правил на агрументы правила

Step8
- Поддержка состояния с откатом

## Привязка выражений к переменным

    bind = expr ':' (ident | identArray)
    identArray = "[" ident ("," ident)* ']'

Реализовать с помощью внутреннего правила bind. 

Во внутреннем правиле rule (внутри функции парсера rule): 
- в начале: создаем новую чистую область переменных: `this.scopes.push({})`. 
- по завершению очищаем область переменных: `this.scopes.pop()`

Текущая область видимости переменных доступна по `this.scope` (что равно `this.scopes[this.scopes.length-1]`) из любого парсера (parseFn).

Во внутреннем правиле bind записываем в текущий `this.scope` значение переменной. 

Использование `this.scope`:
- В предикатах `?predicate`
- В выражении исполнения кода `&method`
- В семантических действиях `expr -> action`


## Предикаты могут иметь более широкий смысл - это кастомные парсеры

Предикаты - это функции вида () => bool. Внутри доступно текущее состояние. Но так не будет ясно почему тот или иной предикат вернул false. Эту проблему можно решить, если предикат будет возвращать IParseResult. И если он возвращает IParseFail, то можно снабдить ответ описанием ошибки. Но можно пойти еще немного дальше и превратить предикаты в кастомные парсеры. 

Semantic actions тоже могут быть парсерами. 

Кроме того концепция кастомных парсеров избавляет нас еще от одной сущности - выражений исполнения кода `&method`. Это тоже может быть кастомный парсер. 

А чтобы упростить код простых семантических действий, предикатов и простых методов (которые всегда успешно выполняются, т.е. возвращают success), можно ввести конвенцию: 
Если возвращеное значение кастомного парсера не является IParserResult, то:
- если это false, вернуть IParserFail
- иначе обернуть его в IParserSuccess.
Т.о. если вы хотите, чтобы ваш метод успешно отработал и вернул результат false, то нужно явно вернуть this.success(false).